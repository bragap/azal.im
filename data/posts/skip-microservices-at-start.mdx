---
title: "Why You (Probably) Shouldn’t Start Your Project with Microservices"
description: "A critical reflection on the hype around microservices, and why starting simple with a modular monolith might be a wiser architectural choice."
cover: /blog/skip-microservices-at-start.png
date: 2025-03-14
---

Let’s be honest, if you’ve browsed job posts or followed tech influencers recently, you’ve probably felt a bit of FOMO. Everyone’s talking about microservices, Kubernetes, event-driven architectures, distributed tracing, and enough acronyms to fill a startup pitch deck.

It’s almost like if your system isn’t built on microservices, you’re doing it wrong. Right?

Well, not exactly.

In this post, I want to challenge this mindset. Not because microservices are bad, as they’re powerful and necessary _in the right context_. But because starting a new project with microservices often introduces way more pain than gain.

Let’s talk about why.

---

# The Illusion of Microservice Superpowers

There’s this shiny aura around microservices, as if breaking a system into dozens of little independent services automatically makes your app scalable, modern, and “enterprise-grade”.

What we often don’t hear is that **many companies, including giants like Amazon**, have started migrating parts of their systems _back_ to monolithic architectures, saving millions in the process.

That’s right. The same companies that popularized microservices are now rethinking them.

---

# Monoliths Aren’t Evil - Just Misunderstood

Let’s step back.

A **monolith** is just a system where everything runs in the same process: customer registration, order processing, reporting, all bundled up. Traditionally, you’ve got one codebase and one database.

And you know what? That’s not necessarily a bad thing.

## Pros of Monoliths:

- Easy to build, test, and deploy
- Great for early-stage products
- Simple to scale vertically (more CPU/RAM) or even horizontally (via replicas and a load balancer)

## Cons:

- Hard to scale just one part of the system
- Tight coupling between components
- Collaboration bottlenecks when too many developers are stepping on each other’s toes in the same repo

These drawbacks become more pronounced **as you grow**, but in the beginning? A well-structured monolith might be your best friend.

---

# Microservices: Power, at a Cost

Microservices bring flexibility and scalability, **but also complexity**.

Every microservice needs:

- Its own codebase
- Its own database
- Its own CI/CD pipeline
- Its own monitoring, logging, tracing setup
- A clear communication strategy (REST, gRPC, messaging, etc.)
- Infrastructure orchestration (containers, service discovery, failover, retries...)

That’s a lot to manage, especially when your product isn’t even validated yet.

In early development, your biggest priority should be **shipping quickly** and **validating your idea**, not building a distributed system worthy of a Netflix tech talk.

---

# 3 Reasons to Avoid Microservices at the Start

Let me break it down.

## 1. **Too Much Complexity, Too Soon**

Microservices force you to make architectural decisions early, often _before_ you fully understand your business domain.

Worse, you’ll spend weeks setting up infra when you should be building features and getting feedback.

## 2. **They’re Not for Everyone**

Microservices were made to solve problems of **scale**, both system and team scale.

If you’re working with a small dev team (or alone), you don’t need 15 services, 15 Git repos, and 15 headaches. You need one well-written app that’s easy to reason about.

## 3. **You Don’t Know the Domain Yet**

In the beginning, the business domain is a moving target. You’re still figuring things out. If you split the system too early, you’ll likely create boundaries that don’t reflect real business responsibilities - and that leads to endless refactoring.

---

# The Smarter Path: Modular Monoliths

Here’s a better approach: start with a **modular monolith**.

Think of it like this: instead of one big ball of code, you structure your application as **modules**, each with a clear responsibility. These modules represent **bounded contexts**, which are areas of your domain that are cohesive and self-contained.

For example, in an e-commerce system:

- A module for Product Catalog
- Another for Order Management
- One for Payments
- And so on

Each module can have:

- Its own domain model
- Its own business rules
- Its own unit and integration tests
- Even its own schema (within the same database)

You get the simplicity of a monolith, with the organization of a well-thought-out architecture.

And here's the kicker: **when the time comes**, and if your team and product truly need it, you can start extracting these modules into microservices. Cleanly. Safely. With confidence.

---

# Evolve, Don’t Overengineer

There’s a time and place for microservices. If you’re a huge company with hundreds of engineers, separate teams, and scalability issues, then go for it.

But if you’re building something new, such as a startup MVP, a side project, or a client system, start with what’s simple and sustainable.

**Build a modular monolith. Learn the domain. Deliver value. Then evolve.**

That’s how software grows with your understanding, rather than collapsing under complexity.

Let’s stop chasing hype and start building smarter.
